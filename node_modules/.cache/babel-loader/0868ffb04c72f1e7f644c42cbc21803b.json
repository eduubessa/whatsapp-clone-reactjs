{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar throttle_debounce_1 = require(\"throttle-debounce\");\n\nvar session_1 = require(\"./session\");\n\nvar util_1 = require(\"./util\");\n\nvar js_util_1 = require(\"@giphy/js-util\");\n\nvar send_pingback_1 = require(\"./send-pingback\");\n\nvar queuedPingbacks = {};\nvar loggedInUserId = '';\n\nfunction fetchPingbackRequest() {\n  js_util_1.forEach(queuedPingbacks, function (actionMap, pingbackType) {\n    if (actionMap) {\n      js_util_1.forEach(actionMap, function (action, responseId) {\n        // if there are no actions lined up inside this pingbackType do nothing\n        if (action.length) {\n          var session = session_1.createSession(pingbackType, action, responseId, loggedInUserId);\n          send_pingback_1.sendPingback(session); // empty this specific batch\n\n          actionMap[responseId] = [];\n        }\n      });\n    }\n  });\n}\n\nvar debouncedPingbackEvent = throttle_debounce_1.debounce(1000, fetchPingbackRequest);\n\nvar pingback = function (_a) {\n  var gif = _a.gif,\n      user = _a.user,\n      responseId = _a.responseId,\n      pingbackType = _a.type,\n      actionType = _a.actionType,\n      position = _a.position,\n      attributes = _a.attributes; // not all endpoints provide a response_id\n\n  if (!responseId) {\n    js_util_1.Logger.debug(\"Pingback aborted for \" + gif.id + \", no responseId\");\n    return;\n  }\n\n  var id = gif.id,\n      _b = gif.bottle_data,\n      bottle_data = _b === void 0 ? {} : _b;\n  var tid = bottle_data.tid; // save the user id for whenever create session is invoked\n\n  loggedInUserId = user && user.id ? String(user.id) : loggedInUserId; // the queue doesn't exist for this pingbackType yet so create it\n\n  if (!queuedPingbacks[pingbackType]) queuedPingbacks[pingbackType] = {}; // a map of actions based on pingback type\n\n  var actionMap = queuedPingbacks[pingbackType]; // we just created it so ! is ok\n  // create the searchRepsonseId queue\n\n  if (!actionMap[responseId]) actionMap[responseId] = []; // add the action\n\n  actionMap[responseId].push(util_1.getAction(actionType, String(id), tid, position, attributes)); // if there's a tid, skip the queue\n\n  tid ? fetchPingbackRequest() : debouncedPingbackEvent();\n};\n\nexports.default = pingback;","map":{"version":3,"sources":["../src/pingback.ts"],"names":[],"mappings":";;;;;;AAAA,IAAA,mBAAA,GAAA,OAAA,CAAA,mBAAA,CAAA;;AACA,IAAA,SAAA,GAAA,OAAA,CAAA,WAAA,CAAA;;AAEA,IAAA,MAAA,GAAA,OAAA,CAAA,QAAA,CAAA;;AAEA,IAAA,SAAA,GAAA,OAAA,CAAA,gBAAA,CAAA;;AACA,IAAA,eAAA,GAAA,OAAA,CAAA,iBAAA,CAAA;;AAIA,IAAM,eAAe,GAA+C,EAApE;AAEA,IAAI,cAAc,GAAG,EAArB;;AAEA,SAAS,oBAAT,GAA6B;AACzB,EAAA,SAAA,CAAA,OAAA,CAAQ,eAAR,EAAyB,UAAC,SAAD,EAAuB,YAAvB,EAAsD;AAC3E,QAAI,SAAJ,EAAe;AACX,MAAA,SAAA,CAAA,OAAA,CAAQ,SAAR,EAAmB,UAAC,MAAD,EAAkC,UAAlC,EAAoD;AACnE;AACA,YAAI,MAAM,CAAC,MAAX,EAAmB;AACf,cAAM,OAAO,GAAG,SAAA,CAAA,aAAA,CAAc,YAAd,EAA4B,MAA5B,EAAoC,UAApC,EAAgD,cAAhD,CAAhB;AACA,UAAA,eAAA,CAAA,YAAA,CAAa,OAAb,EAFe,CAGf;;AACA,UAAA,SAAS,CAAC,UAAD,CAAT,GAAwB,EAAxB;AACH;AACJ,OARD;AASH;AACJ,GAZD;AAaH;;AAED,IAAM,sBAAsB,GAAG,mBAAA,CAAA,QAAA,CAAS,IAAT,EAAe,oBAAf,CAA/B;;AAEA,IAAM,QAAQ,GAAG,UAAC,EAAD,EAA0F;MAAvF,GAAG,GAAA,EAAA,CAAA,G;MAAE,IAAI,GAAA,EAAA,CAAA,I;MAAE,UAAU,GAAA,EAAA,CAAA,U;MAAQ,YAAY,GAAA,EAAA,CAAA,I;MAAE,UAAU,GAAA,EAAA,CAAA,U;MAAE,QAAQ,GAAA,EAAA,CAAA,Q;MAAE,UAAU,GAAA,EAAA,CAAA,U,CAAY,CACvG;;AACA,MAAI,CAAC,UAAL,EAAiB;AACb,IAAA,SAAA,CAAA,MAAA,CAAO,KAAP,CAAa,0BAAwB,GAAG,CAAC,EAA5B,GAA8B,iBAA3C;AACA;AACH;;AACO,MAAA,EAAE,GAAuB,GAAG,CAA1B,EAAF;AAAA,MAAI,EAAA,GAAqB,GAAG,CAAR,WAApB;AAAA,MAAI,WAAW,GAAA,EAAA,KAAA,KAAA,CAAA,GAAG,EAAH,GAAK,EAApB;AACA,MAAA,GAAG,GAAK,WAAW,CAAhB,GAAH,CAP+F,CASvG;;AACA,EAAA,cAAc,GAAG,IAAI,IAAI,IAAI,CAAC,EAAb,GAAkB,MAAM,CAAC,IAAI,CAAC,EAAN,CAAxB,GAAoC,cAArD,CAVuG,CAYvG;;AACA,MAAI,CAAC,eAAe,CAAC,YAAD,CAApB,EAAoC,eAAe,CAAC,YAAD,CAAf,GAAgC,EAAhC,CAbmE,CAevG;;AACA,MAAM,SAAS,GAAG,eAAe,CAAC,YAAD,CAAjC,CAhBuG,CAgBtD;AAEjD;;AACA,MAAI,CAAC,SAAS,CAAC,UAAD,CAAd,EAA4B,SAAS,CAAC,UAAD,CAAT,GAAwB,EAAxB,CAnB2E,CAqBvG;;AACA,EAAA,SAAS,CAAC,UAAD,CAAT,CAAsB,IAAtB,CAA2B,MAAA,CAAA,SAAA,CAAU,UAAV,EAAsB,MAAM,CAAC,EAAD,CAA5B,EAAkC,GAAlC,EAAuC,QAAvC,EAAiD,UAAjD,CAA3B,EAtBuG,CAwBvG;;AACA,EAAA,GAAG,GAAG,oBAAoB,EAAvB,GAA4B,sBAAsB,EAArD;AACH,CA1BD;;AA4BA,OAAA,CAAA,OAAA,GAAe,QAAf","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar throttle_debounce_1 = require(\"throttle-debounce\");\nvar session_1 = require(\"./session\");\nvar util_1 = require(\"./util\");\nvar js_util_1 = require(\"@giphy/js-util\");\nvar send_pingback_1 = require(\"./send-pingback\");\nvar queuedPingbacks = {};\nvar loggedInUserId = '';\nfunction fetchPingbackRequest() {\n    js_util_1.forEach(queuedPingbacks, function (actionMap, pingbackType) {\n        if (actionMap) {\n            js_util_1.forEach(actionMap, function (action, responseId) {\n                // if there are no actions lined up inside this pingbackType do nothing\n                if (action.length) {\n                    var session = session_1.createSession(pingbackType, action, responseId, loggedInUserId);\n                    send_pingback_1.sendPingback(session);\n                    // empty this specific batch\n                    actionMap[responseId] = [];\n                }\n            });\n        }\n    });\n}\nvar debouncedPingbackEvent = throttle_debounce_1.debounce(1000, fetchPingbackRequest);\nvar pingback = function (_a) {\n    var gif = _a.gif, user = _a.user, responseId = _a.responseId, pingbackType = _a.type, actionType = _a.actionType, position = _a.position, attributes = _a.attributes;\n    // not all endpoints provide a response_id\n    if (!responseId) {\n        js_util_1.Logger.debug(\"Pingback aborted for \" + gif.id + \", no responseId\");\n        return;\n    }\n    var id = gif.id, _b = gif.bottle_data, bottle_data = _b === void 0 ? {} : _b;\n    var tid = bottle_data.tid;\n    // save the user id for whenever create session is invoked\n    loggedInUserId = user && user.id ? String(user.id) : loggedInUserId;\n    // the queue doesn't exist for this pingbackType yet so create it\n    if (!queuedPingbacks[pingbackType])\n        queuedPingbacks[pingbackType] = {};\n    // a map of actions based on pingback type\n    var actionMap = queuedPingbacks[pingbackType]; // we just created it so ! is ok\n    // create the searchRepsonseId queue\n    if (!actionMap[responseId])\n        actionMap[responseId] = [];\n    // add the action\n    actionMap[responseId].push(util_1.getAction(actionType, String(id), tid, position, attributes));\n    // if there's a tid, skip the queue\n    tid ? fetchPingbackRequest() : debouncedPingbackEvent();\n};\nexports.default = pingback;\n//# sourceMappingURL=pingback.js.map"]},"metadata":{},"sourceType":"script"}